{
 "id": "40090",
 "text": "O QNX é um sistema operacional do tipo Unix, de tempo real e arquitetura micronúcleo inicialmente desenvolvido pela empresa QNX Software Systems e destinado sobretudo a sistemas embarcados. É utilizado em processos altamente críticos como controle de voo, controle de esteiras de fábricas, sinais de trânsito, usinas nucleares e equipamentos médicos,Análise Sobre o Sistema Operacional QNX http://onqpl.blogspot.nl/2012/02/qnx-announces-new-wireless- medical.html é também utilizado como interface gráfica em automóveishttp://www.washingtonpost.com/cars/a-look-at-the-near-future-of-in- car-technology-qnx- car-2/2012/09/19/a3266bf0-0262-11e2-9132-f2750cd65f97_story.html e como base do sistema operacional utilizado no BlackBerry PlayBook. == Descrição == O QNX é um sistema operacional multiusuário e multitarefa utilizado em operações que necessitam de equipamentos com estabilidade total na realização das tarefas, onde é prioridade é a estabilidade e segurança. QNX é utilizado em roteadores de rede, instrumentos médicos, unidades telemáticas de veículos, sistemas de segurança e de defesa, robótica industrial e outras aplicações de missões críticas. O desenvolvimento de aplicativos sob QNX é realizado através do compilador Watcom C ou C++. Existe, entretanto, uma versão do compilador GNU C/C++, para o QNX. A parte visual do QNX é realizada pela sua própria interface gráfica, a PHOTON. As atuais versões do QNX já vem com diversos aplicativos disponíveis, inclusive um navegador para internet próprio, o \"Voyager\". Em 2010, a Research In Motion (RIM), fabricante do BlackBerry, adquiriu o QNX e o implementou em seu primeiro tablet PC, o PlayBook, concorrente direto do iPad, da Apple. == Arquitetura do Núcleo (Kernel) == O núcleo do QNX é de um tipo chamado micronúcleo. Ao contrário dos núcleos monolíticos, a ideia é desenvolver o mínimo de operações necessárias dentro do núcleo. Os outros serviços são providos através de outros processos opcionais. No QNX o núcleo chamado de \"procnto\". A ideia não é simplesmente fazer um kernel pequeno, mas sim torná-lo modular, o que consequentemente diminuirá o tamanho. Ele é utilizado para juntar os módulos do sistema operacional. O kernel foi desenvolvido na linguagem C. A alta performance está relacionada às sucessivas redefinições de algoritmos e estruturas de dados. Desde sistemas embarcados com memória extremamente limitada a sistemas com gigabytes de memória rodam o QNX. A maioria dos serviços de tempo real e threads são implementados diretamente no núcleo, o que dispensa módulos adicionais para o acesso a esses serviços. Além disso, vários outros serviços são suportados, como semáforos e mutexes. Operações que exigem mais recursos, são carregadas em processos externos. == Chamadas ao Sistema (System Calls) == O QNX, por se tratar de um sistema micronúcleo, implementa um sistema de mensageria, o IPC (Interprocess Communication). Estas mensagens são pacotes de bytes passados de um processo para o outro, que permitem transmitir dados e meios de sincronização da execução de vários processos. O IPC supervisiona o roteamento de mensagens e também gerencia as mensagens de proxies e sinais. * Mensagens: Fornece comunicação síncrona entre processos cooperativos, onde o remetente exige uma prova de recebimento e uma confirmação para mensagem. * Proxies: São especialmente adequados para notificação de eventos onde o remetente não precisa interagir com destinatário * Sinais: Usados para suportar comunicação assíncrona entre processos. === Mensagens === Como o IPC de mensagens espera uma confirmação de recebimento, no seu conteúdo ela utiliza funções da linguagem C. Quando é realizada a sincronização entre processos, são utilizadas as funções SEND(), RECEIVE() e REPLY. A partir do momento que uma mensagem de sincronização é disparada, o processo remetente fica em estado de bloqueio, sendo liberado apenas ao receber o retorno do processo destinatário. === Proxies === É uma forma de mensagem não bloqueante adequada especialmente para notificação de eventos onde o remetente não precisa interagir com o destinatário. A única função de um proxy é enviar uma mensagem fixa a um processo especifico que possui o proxy, onde é possível enviar a mensagem para um processo, sem que o remetente fique bloqueado ou esperando um retorno. === Sinais === São métodos tradicionais de comunicação assíncrona. Um sinal é considerado entregue a um processo quando a ação deferida por ele é realizada pelo destinatário. Um processo pode estabelecer um sinal sem nenhuma intervenção. Nenhum dado é transmitido com sinal. Entre o tempo que o sinal é gerado e o tempo que ele é entregue, ele é considerado pendente. Os sinais são entregues a um processo quando o processo esta pronto para executar no escalonador. Se o processo não tomar nenhuma ação especial para manipular sinais, ação padrão é executada – finalizar o processo. Se o processo ignorar o sinal, não ocorre nenhum efeito no processo quando ele é entregue. == Gerência de processos e threads == \"De forma simplificada uma thread (computação) pode ser definido como uma sub-rotina de um programa que pode ser executada de forma assíncrona, ou seja executada paralelamente ao programa chamador. O programa deve especificar os threads associando-os às sub rotinas assíncronas. Desta forma multithreads possibilitam a execução concorrente de sub-rotinas dentro de um mesmo processo\".MACHADO, Francis; MAIA, Luiz. Arquitetura de Sistemas Operacionais. 4 ed. Rio de Janeiro: LTC Editora. Rio de Janeiro, 2007. Em ambientes multithread existe um ganho de desempenho, pois são diversas instruções em um mesmo processo, ou seja, é como se diversos processos estivessem sendo executados de forma concorrente, porém fazendo uso de apenas um contexto de hardware, dividindo assim o mesmo endereçamento, com isso a comunicação é bem mais rápida, pois não envolve mecanismos lentos. Também não existe a criação, troca e eliminação de processos, diminuindo assim o overhead. As threads são escalonadas assim como os processos. === Threads === No QNX, que é um sistema multitarefa, o responsável por decidir qual thread deve estar sendo executada em um dado instante é o kernel. Ele também é o responsável por escalonar, efetuar as trocas de contexto e salvar as informações da thread que esta saindo da CPU nos registradores de controle. Para garantir que duas threads não acessem simultaneamente um recurso compartilhado (seção critica), o QNX implementa a técnica de Exclusão Mutua com sincronização condicional (semáforos). == Escalonamento (Scheduling) == As decisões de escalonamento são realizadas pelo microkernel nas seguintes situações: * Quando o processo está bloqueado. * O timeslice de um processo em execução esgotou. * Processo em execução sofre preempção. Todo processo criado no QNX recebe uma prioridade, a qual o escalonador utiliza para selecionar o próximo processo com maior prioridade que deve estar em no estado ready (pronto), ou seja, podendo utilizar os recursos da CPU. Os métodos de escalonamento podem ser de três tipos: escalonamento FIFO, escalonamento Round Robin, e escalonamento adaptativo. Cada processo no sistema operacional pode utilizar qualquer um desses métodos, porém somente é aplicado os métodos em situações com dois ou mais processos com mesma prioridade e com o estado ready, ou seja, pronto para utilizar os recursos da CPU. Caso um processo com maior prioridade torne-se ready, então causa a preempção dos processos de baixa prioridade. No escalonamento FIFO a condição que o método seja executado é que o processo renuncie o controle de forma voluntária, não fazendo chamadas ao método ou através de preempção por um processo com maior prioridade. No escalonamento Round-Robin, a condição para que o método continue executando é o mesmo procedimento do escalonamento FIFO, porém acrescido de mais um condição onde caso seja esgotado o timeslice do processo então há a preempção e o próximo processo no estado Ready terá o controle. No escalonamento adaptativo, caso o timeslice do processo termine então a prioridade do processo é reduzida em uma unidade, procedimento conhecido como deterioração de prioridade. Neste caso o processo não é bloqueado. A prioridade do processo não cairá mais que uma unidade, mesmo que o timeslice esgote novamente sem bloquear. Caso o processo seja bloqueado então retorna para sua prioridade original. O escalonamento adaptativo é o método default do criado pelo Shell. == Bibliografia == * DO PRADO, Rodrigo; VICENTE, William. Sistema Operacional QNX. Monografia apresentada para banca na Universidade de Campinas: 1998. * TENENBAUM, Andrew S. Sistemas Operacionais Modernos. 2 ed. São Paulo: Pearson Education do Brasil, 1994. * KRTEN, Rob. QNX Neutrino RTOS. Ottawa: QNX Software Systems GmbH & Co. KG., 2009. == Ligações externas == *Página Oficial Categoria:Sistemas operacionais embarcados Categoria:Sistemas Unix-like leves Categoria:Micronúcleo Categoria:Sistemas operacionais proprietários",
 "title": "QNX"
}